#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

/**
 *   @func:     int lockf(int fd, int cmd, off_t len);
 *        
 *   @brief     
 *      
 *   @param     fd 是你想要操作的文件的文件描述符。
 *   @param     cmd 是你想要执行的操作，可以是以下几个值之一：F_LOCK、
 *                                                     F_TLOCK、
 *                                                     F_ULOCK 或 F_TEST。
 *   @param     len 是你想要锁定或解锁的字节数。
 * 
 *   @return 
 * 
 *   @note  如果一个进程已经对一个文件加了锁，而另一个进程试图读取同一个文件，那么具体的行为取决于锁的类型和操作系统的实现。

            在 Unix-like 系统中，通常有两种类型的锁：共享锁（也称为读锁）和独占锁（也称为写锁）。

            如果一个进程已经对一个文件加了共享锁，那么其他进程仍然可以对这个文件加共享锁并读取这个文件。但是，如果一个进程试图对这个文件加独占锁或写入这个文件，那么这个进程会被阻塞，直到第一个进程释放了它的锁。

            如果一个进程已经对一个文件加了独占锁，那么其他进程不能对这个文件加任何类型的锁或读取或写入这个文件。如果一个进程试图这样做，那么这个进程会被阻塞，直到第一个进程释放了它的锁。

            然而，需要注意的是，lockf 函数提供的是建议性锁，而不是强制性锁。这意味着，这些锁只对那些检查这些锁的进程有效。如果一个进程不检查这些锁，那么它可以无视这些锁并直接读取或写入文件。因此，建议性锁只能在那些遵守相同锁协议的进程之间提供协调机制。

            此外，lockf 函数的锁是与进程关联的，而不是与线程关联的。这意味着，如果一个进程中的一个线程对一个文件加了锁，那么这个进程中的其他线程仍然可以读取或写入这个文件。
*/

int main() {
    int fd = open("file.txt", O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    if (lockf(fd, F_LOCK, 0) == -1) {
        perror("lockf");
        return 1;
    }

    // 在这里，文件已经被锁定，你可以进行你的操作...
    //lockf 函数提供的是建议性锁，而不是强制性锁。
    //如果一个进程不检查这些锁，那么它可以无视这些锁并直接读取或写入文件。因此，建议性锁只能在那些遵守相同锁协议的进程之间提供协调机制。
    // 其他进程会阻塞等待 取决于实现

    if (lockf(fd, F_ULOCK, 0) == -1) {
        perror("lockf");
        return 1;
    }

    close(fd);

    return 0;
}